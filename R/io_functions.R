

#' Split a path name into into its components
#'
#' @param path A path name
#'
#' @return a vector of path components (starting with the last component)
#' @export
#'
#' @examples
split_path <- function(path) {
  if (dirname(path) %in% c(".", "/", "//", "\\" , "\\\\", path))
    return(basename(path))
  return(c(basename(path), split_path(dirname(path))))
}

#' Remove top-level directory in a full file path.
#'
#' Useful when top-level directory
#' name was changed during data curation
#'
#' @param pathname A string path
#'
#' @return New pathname with top-level directory removed
#' @export
#'
#' @examples
remove_tld <- function(pathname) {
  path_comps <- split_path(pathname)
  do.call('file.path', as.list(path_comps[(length(path_comps)-1):1]))
}

#' Read Trial Results
#'
#' Read & combine trial results files for a given experiment within a data
#' folder.
#'
#' @param data_dir Parent directory where data are stored
#' @param ... Arguments to be passed on to read_csv
#'
#' @return A combined data frame of all trial results.
#' @export
#'
#' @examples
read_trial_results <- function(data_dir, ...){

  read_results_file <- function(fn, ...) {
    fn %>%
      readr::read_csv(show_col_types = FALSE, col_names = TRUE, ...) %>%
      dplyr::mutate(res_path = dirname(fn))
  }

  list.files(path = file.path(data_dir),
             pattern = "*trial_results.csv",
             recursive = TRUE,
             full.names = TRUE) %>%
    purrr::map(read_results_file, ...) %>%
    purrr::list_rbind()
}

#' Read log messages
#'
#' Read log messages from log files to combine with trial results
#'
#' @param data Data frame of trial results, containing column `res_path`
#' @param messages Vector of string messages to detect
#' @param .colnames Vector of column names to insert into `data_dir`
#'
#' @return
#' @export
#'
#' @examples
#' # find "killed by magical force" messages in study 2
#' trials_with_log_messages <-
#' trials_raw %>%
#'    read_log_messages("ConfrontedThreat 0 You were killed by a magical force",
#'                      "killed_by_magical_force" = "...1")

  read_log_messages <- function(data, messages, .colnames) {
    read_log_file <- function(res_path, messages, .colnames) {
      suppressWarnings(read_csv(file.path(res_path, "sessionlog", "log.csv"))) %>%
        find_log_message(messages, .colnames) %>%
        dplyr::mutate(res_path = res_path)
    }

    data %>%
      pull(res_path) %>%
      unique() %>%
      purrr::map(read_log_file,
                 messages, .colnames) %>%
      purrr::list_rbind() %>%
      dplyr::left_join(data, ., by = c("res_path", "trial_num"))
  }

#' Update file pointers
#'
#' Update pointers to CSV files associated with trials (e.g. Movement files)
#' in supplied columns. This updates the absolute paths (which might have been changed)
#' stored in columns provided combines with the column `res_path` as generated by
#' `read_trial_results`. This function takes care with changes in file location
#' or renaming of individual participant folders.
#'
#' @param data  A dataframe of trial results
#' @param .cols A tidyselect specification of columns (e.g. `c(col1, col2)`).
#'              Default are columns that end with `_location_0`
update_file_pointers <- function(data,
                                 .cols = tidyselect::ends_with("_location_0")) {
  update_path <- function(old_path, res_path) {
    if (is.na(old_path))
      return(NA)
    subdir_list <-
      c(
        "camera",
        "othersessiondata",
        "othertrialdata",
        "participantdetails",
        "screen",
        "sessionlog",
        "settings",
        "trackers"
      )
    path_parts <- split_path(old_path)
    indx <- which(path_parts %in% subdir_list)[1]
    do.call(file.path, as.list(c(res_path, path_parts[seq(from = indx, to = 1)])))
  }

  data %>%
    dplyr::rowwise() %>%
    dplyr::mutate(dplyr::across({{.cols}},
    ~purrr::map2_chr(., res_path, update_path))) %>%
    dplyr::ungroup()
}


#' Read CSV Files
#'
#' Read CSV files associated with trials (e.g. Movement files) from paths stored
#' in supplied columns. Expects absolute paths, use `update_file_pointers` to
#' update them if necessary.
#' Function uses `read_csv` to read files.
#'
#' @param data A dataframe of trial results
#' @param .cols A tidyselect specification of columns (e.g. `c(col1, col2)`).
#' @param ... Additional arguments passed to `read_csv`.
#' Default are columns that end with `_location_0`
read_csv_files <-
  function(data,
           .cols = tidyselect::ends_with("_location_0"),
           ...) {

    # take care of duplicated "x" column names in early versions of the VRthreat
    repair_names <- function(names) {
      x_cols <- which(names == "pos_x")
      if (length(x_cols) == 2) names[x_cols[2]] <- "pos_z"
      vctrs::vec_as_names(names, repair = "unique")
      }

  read_fn <- function(fname, ...){
    if (is.na(fname)) return(NULL)
    if (!file.exists(fname)) return(NULL)
    if (file.info(fname)$size == 0) return(NULL)
    suppressWarnings(
      readr::read_csv(
        fname,
        n_max = 1e6,
        lazy = FALSE,
        name_repair = repair_names,
        ...
      )
    )
  }

  data %>%
    dplyr::rowwise() %>%
    dplyr::mutate(dplyr::across(
      {{ .cols }},
      ~list(read_fn(., ...)),
      .names = "{stringr::str_replace(.col, '_location', '_data')}"
    )) %>%
    dplyr::ungroup()
}

#' Read JSON Files
#'
#' Read json files associated with trials from paths stored in supplied
#' columns. Expects absolute paths, use `update_file_pointers` to
#' update them if necessary. Function uses
#' `jsonlite::read_json` to read files.
#'
#' @param data A dataframe of trial results
#' @param .cols A tidyselect specification of columns (e.g. `c(col1, col2)`).
#' @param ... Additional arguments passed to `read_json`.
#' Default are columns that end with `_json_location_0`
read_json_files <-
  function(data,
           .cols = ends_with("_json_location_0"),
           ...) {

    read_fn <- function(fname) {
      if (is.na(fname))
        return(NULL)
      fname <- file.path(ifelse(endsWith(fname, ".json"),
                                fname,
                                paste0(fname, ".json")))
      if (!file.exists(fname))
        return(NULL)
      jsonlite::read_json(fname,
                          ...)
    }

    data %>%
      dplyr::rowwise() %>%
      dplyr::mutate(dplyr::across({
        {
          .cols
        }
      },
      ~ list(read_fn(.)),
      .names = "{stringr::str_replace(.col, '_location', '_data')}")) %>%
      dplyr::ungroup()
  }

#' Read participant details from files
#'
#' Will assume directory names assume to original participant ids, don''t use if
#' these have been changed.
#'
#' @param df A dataframe of trial results
#' @param data_dir Parent directory where data are stored
#'
#' @return Data frame with new columns
#' @export
#'

#' @examples
read_participant_details <- function(df, data_dir) {
  tibble::tibble(ppid = unique(df$ppid)) %>%
    dplyr::mutate(fn = file.path(
      data_dir,
      ppid,
      "S001",
      "participantdetails",
      "participant_details.csv"
    )) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(dplyr::across(.cols = tidyselect::matches("fn"),
                  ~ suppressWarnings(readr::read_csv(
                    .,
                    col_types = readr::cols()
                  ))))  %>%
    tidyr::unpack("fn") %>%
    dplyr::select(!matches("trackers_enabled")) %>%
    dplyr::right_join(df, by = "ppid")
}


#' Read complete study data
#'
#' This function reads all VRthreat output data from one study into a data frame.
#' The
#'
#' @param rawpath  The path that contains the individual subjects' directories.
#' The path name may have been changed during data curation, and the original
#' top-level directory name in the VR output will be replaced by this path.
#' @param metapath The path that contains the meta data. This must contain the
#' following csv files, which are used in their order of appeareance:
#' 1. replacements.csv: joins interrupted participants. Must contain columns
#'    ppid_old, ppid_new, session_num_new, last_trial_exclude
#' 2. participants_excluded.csv: participants to exclude. Must contain column
#'    ppid
#' 3. trial_exclusions.csv: individual trials to exclude. Must contain columns
#'    ppid, session_num, trial_num
#' @return A data frame with all experiment data
#' @export
#'
#' @examples
read_study_data <- function(rawpath, metapath) {

# read replacements file
  replacements <-
    readr::read_csv(
      file.path(metapath,
                "replacements.csv"),
      col_types = readr::cols(
        ppid_old = readr::col_character(),
        ppid_new = readr::col_character(),
        session_num_new = readr::col_double(),
        last_trial_exclude = readr::col_double()
      ),
      n_max = 1000
    )

  # read excluded participants
  participants_excluded <-
    readr::read_csv(
      file.path(metapath,
                "participants_excluded.csv"),
      col_types = readr::cols(ppid = readr::col_character()),
      n_max = 1000
    )

  # read excluded trials
  trials_excluded <-
    readr::read_csv(
      file.path(metapath,
                "trial_exclusions.csv"),
      col_types = cols(
        ppid = col_character(),
        session_num = col_double(),
        trial_num = col_double()
      )
    ) %>%
    mutate(excl_trial = 1)

# read raw data
  column_spec <- readr::cols(ppid = readr::col_character(),
                             timeout = readr::col_double())
trials_raw <-
  read_trial_results(rawpath,
                     na = c("", "NA", "Infinity"),
                     col_types = column_spec) %>%
  update_file_pointers() %>%
  # correct ppids for interrupted participants
  apply_replacements(replacements) %>%
  # filter out excluded participants
  dplyr::anti_join(participants_excluded, by = "ppid") %>%
  # and excluded trials
  left_join(trials_excluded,
            by = c("ppid", "session_num", "trial_num")) %>%
  filter(is.na(excl_trial) | excl_trial != 1) %>%
  select(!excl_trial) %>%
  remove_tutorials() %>%
  # read nested CSV files (movement files)
  read_csv_files(
    c(
      head_movement_location_0,
      threat_movement_location_0,
      waist_movement_location_0
    ),
    col_types = readr::cols(
      time = readr::col_double(),
      pos_x = readr::col_double(),
      pos_y = readr::col_double(),
      pos_z = readr::col_double(),
      rot_x = readr::col_double(),
      rot_y = readr::col_double(),
      rot_z = readr::col_double(),
    )
  ) %>%
  # read nested CSV files (tracker files for which rotations are never used, to save memory)
  read_csv_files(
    c(
      righthand_movement_location_0,
      lefthand_movement_location_0,
      rightfoot_movement_location_0,
      leftfoot_movement_location_0
    ),
    col_select = c("time", "pos_x", "pos_y", "pos_z"),
    col_types = readr::cols_only(
      time = readr::col_double(),
      pos_x = readr::col_double(),
      pos_y = readr::col_double(),
      pos_z = readr::col_double(),
    )
  ) %>%
  # read nested CSV files (selected columns for fruit task, to save memory)
  read_csv_files(
    tidyselect::any_of("fruittask0.csv_location_0"),
    col_select = c("time", "event"),
    col_types = readr::cols_only(
      time = readr::col_double(),
      event = readr::col_character()
    )
  ) %>%
  {
    if ("botheyes_eye_tracking_location_0" %in% names((.)))
      read_csv_files(
        .,
        tidyselect::any_of("botheyes_eye_tracking_location_0"),
        col_types = readr::cols(
          time = readr::col_double(),
          gaze_origin_x = readr::col_double(),
          gaze_origin_y = readr::col_double(),
          gaze_origin_z = readr::col_double(),
          gaze_direction_x = readr::col_double(),
          gaze_direction_y = readr::col_double(),
          gaze_direction_z = readr::col_double(),
          eye_openness_left = readr::col_double(),
          eye_openness_right = readr::col_double(),
          pupil_diameter_left = readr::col_double(),
          pupil_diameter_right = readr::col_double(),
          focus_object_raw = readr::col_character(),
          focus_point_x = readr::col_double(),
          focus_point_y = readr::col_double(),
          focus_point_z  = readr::col_double(),
          focus_distance = readr::col_double(),
          focus_threat = readr::col_character()
        )
      )
    else
      (.)
  } %>%
  # read nested JSON files (scenario, sequence)
  read_json_files(c(scenario_location_0,
                             sequence0_location_0))
}

#' Create output folders under an experiment name
#'
#' @param experiment_name A string representing the experiment name.
#'
#' @return Nothing.
#' @export
#'
#' @examples
create_out_folders <- function(experiment_name) {
  out_folder <- "out"
  experiment_folder <- file.path("out", experiment_name)
  figs_folder <- file.path("out", experiment_name, "figs")
  data_folder <- file.path("out", experiment_name, "data")

  if (!dir.exists(out_folder))
    dir.create(out_folder)
  if (!dir.exists(experiment_folder))
    dir.create(experiment_folder)
  if (!dir.exists(figs_folder))
    dir.create(figs_folder)
  if (!dir.exists(data_folder))
    dir.create(data_folder)
}


#' Wrapper around `ggsave` to save figures.
#'
#' @param plt The plot object.
#' @param experiment_name The experiment name.
#' @param fname The file name including extension.
#' @param type Type passed to `ggsave`
#' @param device Device passed to `ggsave` (default: "png")
#' @param dpi dpi passed to `ggsave`
#' @param width width of the plot (default units are inches)
#' @param height height of the plot (default units are inches)
#' @param ... Other arguments passed to `ggsave`.
#'
#' @return
#' @export
#'
#' @examples
save_fig <-
  function(plt,
           experiment_name,
           fname,
           type = "cairo",
           device = "png",
           dpi = 600,
           width = 4,
           height = 4,
           ...) {
    ggsave(
      file.path("out", experiment_name, "figs", fname),
      plt,
      type = type,
      dpi = dpi,
      width = width,
      height = height,
      device = device,
      ...
    )
  }
